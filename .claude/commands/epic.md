---
description: Epic 기획 + Task 분해. 작업 유형을 먼저 파악하고 각 상황에 맞는 분석/설계/구현 단계를 진행합니다.
tags: [workflow, planning, serena]
---

# /epic - Category-Based Epic Planning

작업 유형을 먼저 파악하고, 각 카테고리에 맞는 체계적인 분석과 Task 분해를 수행합니다.

## 사용법

```bash
/epic "주문 기능"
/epic "결제 시스템 리팩토링"
/epic "PG사 연동"
/epic "회원가입" --no-serena    # Serena 없이 실행
```

## 🔗 Serena 통합 (기본 활성화)

```
/epic 실행 시 Serena 자동 연동:

┌─────────────────────────────────────────────────┐
│ 1️⃣ 프로젝트 활성화                              │
│    → activate_project(현재 프로젝트)            │
│                                                 │
│ 2️⃣ 컨벤션 규칙 로드                            │
│    → read_memory("convention-*-validation-*")  │
│    → read_memory("domain-rules-*")             │
│                                                 │
│ 3️⃣ 코드베이스 분석 (기존 코드 검색)            │
│    → find_symbol() - 관련 클래스 검색          │
│    → get_symbols_overview() - 구조 파악        │
│                                                 │
│ 4️⃣ Epic 문서 저장                              │
│    → write_memory("epic-{feature}", content)   │
└─────────────────────────────────────────────────┘

비활성화: --no-serena 옵션 사용
```

## 실행 프로세스

```
/epic "{작업명}"
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 0️⃣ 작업 유형 파악                                                   │
│                                                                     │
│    "어떤 유형의 작업인가요?"                                         │
│                                                                     │
│    1. 🆕 신규 기능 개발 - 새로운 도메인/Aggregate 생성               │
│    2. ➕ 기능 확장 - 기존 기능에 새 기능 추가                         │
│    3. 🔄 리팩토링 - 구조 개선 (동작 유지)                            │
│    4. 🐛 버그 수정 - 잘못된 동작 수정                                │
│    5. 🔌 외부 연동 - 외부 시스템 API 통합                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
        ↓
   [선택된 유형에 맞는 프로세스 진행]
```

---

## 1️⃣ 🆕 신규 기능 개발 (New Feature)

> **새로운 Aggregate/도메인을 처음부터 생성**

### 프로세스

```
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 1: 비즈니스 분석                                                │
├─────────────────────────────────────────────────────────────────────┤
│ • 핵심 질문: "어떤 비즈니스 문제를 해결하는가?"                       │
│ • 비즈니스 규칙 도출 (BR-001, BR-002...)                            │
│ • 유즈케이스 시나리오 작성                                          │
│ • 예외/엣지케이스 파악                                              │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 2: 기존 코드 분석 (Serena MCP)                                  │
├─────────────────────────────────────────────────────────────────────┤
│ • 관련 도메인 검색: 유사 Aggregate 패턴 확인                         │
│ • 재사용 가능 VO 확인: Money, Address, Email 등                     │
│ • 기존 도메인과의 관계 파악: Long FK 대상 식별                       │
│ • 참고할 구현 패턴 선정: "Payment처럼 상태머신 필요?"                │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 3: 도메인 설계                                                  │
├─────────────────────────────────────────────────────────────────────┤
│ • Aggregate Root 정의                                               │
│ • Entity / VO 식별                                                  │
│ • Domain Event 정의                                                 │
│ • Invariant(불변식) 명세                                            │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 4: API 스펙 초안                                                │
├─────────────────────────────────────────────────────────────────────┤
│ • Command API: POST/PUT/DELETE 엔드포인트                           │
│ • Query API: GET 엔드포인트                                         │
│ • Request/Response DTO 구조                                         │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 5: Task 분해                                                    │
├─────────────────────────────────────────────────────────────────────┤
│ • Domain Layer Task (Aggregate, VO, Event)                          │
│ • Application Layer Task (UseCase, Service)                         │
│ • Persistence Layer Task (Entity, Repository, Mapper)               │
│ • REST API Layer Task (Controller, DTO)                             │
│ • 의존성 순서 정의                                                   │
└─────────────────────────────────────────────────────────────────────┘
```

### 산출물
- 비즈니스 규칙 테이블
- 도메인 모델 설계
- API 스펙 초안
- Layer별 Task 목록

---

## 2️⃣ ➕ 기능 확장 (Feature Extension)

> **기존 Aggregate/기능에 새로운 기능 추가**

### 프로세스

```
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 1: 영향도 분석 (Serena MCP) ⭐ 가장 중요                        │
├─────────────────────────────────────────────────────────────────────┤
│ • 대상 코드 검색: 수정할 클래스/메서드 식별                          │
│ • 참조 분석: 이 코드를 사용하는 곳 모두 파악                         │
│ • 테스트 커버리지: 기존 테스트 확인                                  │
│ • 수정 범위 산정: 영향받는 파일 목록                                 │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 2: 호환성 검토                                                  │
├─────────────────────────────────────────────────────────────────────┤
│ • 핵심 질문: "기존 기능에 영향 없이 추가 가능한가?"                  │
│ • API 하위 호환성: 기존 API 스펙 유지 여부                          │
│ • DB 스키마 호환성: 마이그레이션 필요 여부                           │
│ • 기존 클라이언트 영향: Breaking Change 여부                        │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 3: 변경 설계                                                    │
├─────────────────────────────────────────────────────────────────────┤
│ • 추가할 필드/메서드 정의                                           │
│ • 수정할 기존 코드 명세                                             │
│ • 신규 생성 코드 명세                                               │
│ • 마이그레이션 스크립트 (필요시)                                    │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 4: Task 분해                                                    │
├─────────────────────────────────────────────────────────────────────┤
│ • 수정 Task: 기존 파일 변경 (파일별 분리)                           │
│ • 신규 Task: 새로 생성할 파일                                       │
│ • 테스트 Task: 기존 테스트 수정 + 신규 테스트                       │
│ • 마이그레이션 Task (필요시)                                        │
└─────────────────────────────────────────────────────────────────────┘
```

### 산출물
- 영향도 분석 맵
- 호환성 체크리스트
- 수정/신규 파일 목록
- Task 목록 (수정 vs 신규 구분)

---

## 3️⃣ 🔄 리팩토링 (Refactoring)

> **동작 변경 없이 코드 구조 개선**

### 프로세스

```
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 1: 문제점 분석                                                  │
├─────────────────────────────────────────────────────────────────────┤
│ • 핵심 질문: "무엇이 문제인가? 왜 리팩토링이 필요한가?"              │
│ • Code Smell 식별: 중복, 긴 메서드, God Class 등                    │
│ • 규칙 위반 확인: Zero-Tolerance 규칙 위반 여부                     │
│ • 기술 부채 명세: 구체적인 문제점 목록화                            │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 2: 테스트 현황 확인 ⭐ 가장 중요                                │
├─────────────────────────────────────────────────────────────────────┤
│ • 테스트 커버리지 확인: 리팩토링 대상 코드의 테스트 존재 여부       │
│ • 테스트 품질 검토: 동작을 검증하는 테스트인가?                     │
│ • 테스트 보강 필요 여부: 리팩토링 전 테스트 추가 필요?              │
│ ⚠️ 테스트 없으면 리팩토링 위험! 테스트 먼저 작성                    │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 3: 목표 구조 설계                                               │
├─────────────────────────────────────────────────────────────────────┤
│ • Before/After 비교: 현재 vs 목표 구조                              │
│ • 리팩토링 기법 선택: Extract, Move, Rename, Inline 등              │
│ • 단계별 변환 계획: 한 번에 하나씩, 점진적으로                      │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 4: Task 분해                                                    │
├─────────────────────────────────────────────────────────────────────┤
│ • 테스트 보강 Task (필요시): 먼저 테스트 추가                       │
│ • 리팩토링 Task: 작은 단위로 분리, 각 단계 후 테스트 통과 확인      │
│ • 검증 Task: 전체 테스트 통과 확인                                  │
│ ⚠️ 각 Task는 "테스트 통과" 상태를 유지해야 함                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 산출물
- 문제점 목록
- 테스트 커버리지 리포트
- Before/After 구조 비교
- 점진적 리팩토링 Task 목록

### ⚠️ 리팩토링 원칙
```
1. 테스트 없으면 리팩토링 금지 → 테스트 먼저 작성
2. 한 번에 하나만 변경
3. 매 변경 후 테스트 실행
4. 동작이 바뀌면 리팩토링 아님 → 기능 변경임
```

---

## 4️⃣ 🐛 버그 수정 (Bug Fix)

> **잘못된 동작을 올바르게 수정**

### 프로세스

```
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 1: 재현 확인 ⭐ 가장 중요                                       │
├─────────────────────────────────────────────────────────────────────┤
│ • 핵심 질문: "버그를 재현할 수 있는가?"                              │
│ • 재현 시나리오: 정확한 재현 단계 문서화                            │
│ • 재현 환경: 로컬/스테이징/프로덕션 어디서 발생?                    │
│ • 발생 조건: 항상? 특정 조건에서만?                                 │
│ ⚠️ 재현 안 되면 수정 불가! 재현부터 확보                            │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 2: 근본 원인 분석 (Root Cause Analysis)                         │
├─────────────────────────────────────────────────────────────────────┤
│ • 코드 추적: 버그 발생 지점 → 원인 지점 역추적                      │
│ • 5 Whys: 왜? 를 반복해서 근본 원인 도출                            │
│ • 원인 검증: 원인을 수정하면 버그가 사라지는지 확인                 │
│ • 다른 영향: 같은 원인으로 다른 버그 가능성?                        │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 3: 수정 전략 수립                                               │
├─────────────────────────────────────────────────────────────────────┤
│ • 핵심 질문: "최소 범위로 수정 가능한가?"                            │
│ • 수정 방안 검토: 여러 방안 비교                                    │
│ • 사이드이펙트 검토: 수정으로 인한 다른 영향                        │
│ • 회귀 테스트 범위: 어디까지 테스트해야 하는가                      │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 4: Task 분해                                                    │
├─────────────────────────────────────────────────────────────────────┤
│ • 테스트 Task: 버그 재현 테스트 작성 (먼저!)                        │
│ • 수정 Task: 최소 범위 코드 수정                                    │
│ • 검증 Task: 재현 테스트 통과 + 회귀 테스트                         │
└─────────────────────────────────────────────────────────────────────┘
```

### 산출물
- 재현 시나리오
- Root Cause 분석
- 수정 범위 명세
- 테스트 → 수정 → 검증 Task

### ⚠️ 버그 수정 원칙
```
1. 재현 테스트 먼저 작성 → 실패하는 테스트
2. 최소 범위만 수정 → 과도한 리팩토링 금지
3. 수정 후 테스트 통과 확인
4. 회귀 테스트로 사이드이펙트 확인
```

---

## 5️⃣ 🔌 외부 연동 (Integration)

> **외부 시스템 API와 통합**

### 프로세스

```
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 1: 외부 API 분석                                                │
├─────────────────────────────────────────────────────────────────────┤
│ • API 스펙 정리: 엔드포인트, 파라미터, 응답 형식                    │
│ • 인증 방식: API Key, OAuth, mTLS 등                                │
│ • Rate Limit: 호출 제한 확인                                        │
│ • SLA: 응답시간, 가용성 보장 수준                                   │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 2: 장애 시나리오 분석 ⭐ 가장 중요                              │
├─────────────────────────────────────────────────────────────────────┤
│ • 핵심 질문: "외부 시스템 장애 시 어떻게 동작해야 하는가?"          │
│ • 타임아웃: 얼마나 기다릴 것인가?                                   │
│ • 재시도: 몇 번? 어떤 간격으로?                                     │
│ • 서킷브레이커: 언제 열고 닫을 것인가?                              │
│ • 폴백: 대안 동작은 무엇인가?                                       │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 3: Anti-Corruption Layer 설계                                   │
├─────────────────────────────────────────────────────────────────────┤
│ • Port 정의: 우리 도메인 용어로 인터페이스 정의                     │
│ • Adapter 설계: 외부 API ↔ 우리 도메인 변환                         │
│ • DTO 매핑: 외부 형식 → 내부 형식                                   │
│ • 에러 변환: 외부 에러 → 도메인 예외                                │
└─────────────────────────────────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────────────────────────────────┐
│ STEP 4: Task 분해                                                    │
├─────────────────────────────────────────────────────────────────────┤
│ • Port Task: 도메인 인터페이스 정의                                 │
│ • Client Task: HTTP Client 구현 (타임아웃, 재시도)                  │
│ • Adapter Task: 변환 로직 구현                                      │
│ • 복원력 Task: 서킷브레이커, 폴백 구현                              │
│ • 테스트 Task: Mock 테스트 + 실제 연동 테스트                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 산출물
- 외부 API 스펙 정리
- 장애 대응 전략
- ACL 설계 (Port, Adapter)
- 복원력 설계 (Circuit Breaker, Retry, Fallback)
- Task 목록

### ⚠️ 외부 연동 원칙
```
1. 외부 시스템은 언제든 장애날 수 있다고 가정
2. 타임아웃 필수 설정
3. 재시도는 멱등성 보장될 때만
4. 서킷브레이커로 장애 전파 방지
5. @Transactional 내에서 외부 호출 금지!
```

---

## 출력 문서 형식

```markdown
# Epic: {작업명}

## 메타 정보
- **유형**: 🆕 신규 기능 개발 | ➕ 기능 확장 | 🔄 리팩토링 | 🐛 버그 수정 | 🔌 외부 연동
- **예상 Task 수**: {N}개
- **관련 도메인**: {도메인명}

## 분석 결과

### [유형별 분석 내용]
...

## 설계

### [유형별 설계 내용]
...

## Task 목록

### TASK-001: {Task명}
- **유형**: 신규 생성 | 수정 | 테스트
- **레이어**: Domain | Application | Persistence | REST API
- **예상 크기**: ~{N}K tokens
- **파일**:
  - `path/to/File.java` (신규|수정)
- **설명**: {상세 설명}
- **완료 조건**: {Definition of Done}

### TASK-002: ...

## 의존성 그래프
```
TASK-001
    ↓
TASK-002 ─→ TASK-003
```

## Jira 등록 정보
- **Epic 제목**: [{유형}] {작업명}
- **Epic 설명**: {설명}
- **Sub-tasks**: {Task 목록}
```

---

## Task 분해 기준

### 크기 제한
- **최대 토큰**: ~15,000 tokens
- **최대 파일 수**: 5개 이내
- **최대 변경 라인**: ~500줄

### 유형별 분해 전략

| 유형 | 분해 기준 |
|------|----------|
| 🆕 신규 기능 | Layer별로 분리 |
| ➕ 기능 확장 | 수정 파일별로 분리 |
| 🔄 리팩토링 | 리팩토링 단계별로 분리 (매 단계 테스트 통과) |
| 🐛 버그 수정 | 테스트 → 수정 → 검증 순서로 |
| 🔌 외부 연동 | Port → Client → Adapter → 복원력 순서로 |

---

## Skill 연동

이 커맨드는 **planner** skill을 활성화합니다:
- 작업 유형 파악
- 유형별 분석/설계 진행
- Serena MCP로 기존 코드 분석
- Task 분해 및 크기 산정

---

## Serena Memory 저장 형식

```markdown
# Memory: epic-{feature}

## 메타 정보
- 유형: 🆕 | ➕ | 🔄 | 🐛 | 🔌
- Task 수: N개
- 생성일: YYYY-MM-DD

## 분석 결과
...

## Task 목록
...
```

---

## 옵션

| 옵션 | 설명 | 기본값 |
|------|------|--------|
| `--no-serena` | Serena 통합 비활성화 | 활성화 |

---

## 다음 단계

문서 생성 완료 후:
```bash
/jira-create  # Jira에 Epic + Task 등록 (Serena Memory에서 로드)
```
