---
description: Domain Layer 코딩 규칙 (Aggregate, VO, Event, Exception)
globs: ["**/domain/**/*.java"]
alwaysApply: false
---

# Domain Layer Rules (214개 규칙)

Domain Layer는 비즈니스 로직의 핵심입니다. 외부 의존성 없이 순수 Java로 구현합니다.

---

## 핵심 원칙 (Zero-Tolerance)

| Code | Rule | Detection |
|------|------|-----------|
| AGG-001 | Lombok 절대 금지 | `@Data`, `@Getter`, `@Setter`, `@Builder` |
| AGG-014 | Law of Demeter | getter 체이닝 `a.getB().getC()` |
| VO-006 | VO 불변성 필수 | non-final 필드, setter |
| EXC-001 | Domain Exception만 | raw `RuntimeException` |

---

## Aggregate Root (AGG-*)

### 필수 구조
```java
public class Order {
    // 1. 모든 필드 private final
    private final OrderId id;
    private final CustomerId customerId;  // Long FK 전략
    private final List<OrderLine> orderLines;
    private OrderStatus status;  // 상태만 mutable

    // 2. private 생성자
    private Order(OrderId id, CustomerId customerId, List<OrderLine> orderLines) {
        this.id = id;
        this.customerId = customerId;
        this.orderLines = new ArrayList<>(orderLines);
        this.status = OrderStatus.CREATED;
    }

    // 3. 신규 생성 팩토리 (forNew)
    public static Order forNew(OrderId id, CustomerId customerId, List<OrderLine> lines) {
        validateOrderLines(lines);
        return new Order(id, customerId, lines);
    }

    // 4. 영속화 복원 팩토리 (reconstitute)
    public static Order reconstitute(OrderId id, CustomerId customerId,
            List<OrderLine> lines, OrderStatus status) {
        Order order = new Order(id, customerId, lines);
        order.status = status;
        return order;
    }

    // 5. 도메인 이벤트 발행
    public OrderConfirmedEvent confirm() {
        validateCanConfirm();
        this.status = OrderStatus.CONFIRMED;
        return new OrderConfirmedEvent(this.id, Instant.now());
    }

    // 6. 접근자 메서드 (getter 아님)
    public OrderId id() { return id; }
    public Money totalAmount() {
        return orderLines.stream()
            .map(OrderLine::amount)
            .reduce(Money.ZERO, Money::add);
    }
}
```

### AGG 규칙 상세

| Code | Rule | Severity |
|------|------|----------|
| AGG-001 | Lombok 금지 | BLOCKER |
| AGG-002 | private 생성자 필수 | CRITICAL |
| AGG-003 | forNew() 정적 팩토리 필수 | CRITICAL |
| AGG-004 | reconstitute() 정적 팩토리 필수 | CRITICAL |
| AGG-005 | ID 필드는 불변 (final) | CRITICAL |
| AGG-006 | 컬렉션 방어적 복사 | CRITICAL |
| AGG-007 | 상태 변경은 메서드로만 | MAJOR |
| AGG-008 | 도메인 이벤트 발행 | MAJOR |
| AGG-014 | Law of Demeter 준수 | BLOCKER |
| AGG-015 | Tell, Don't Ask | MAJOR |

### Tell, Don't Ask 패턴
```java
// ❌ BAD - Ask (상태를 묻고 외부에서 판단)
if (order.getStatus() == OrderStatus.CREATED) {
    order.setStatus(OrderStatus.CONFIRMED);
}

// ✅ GOOD - Tell (행동을 요청)
order.confirm();  // 내부에서 검증 + 상태 변경
```

---

## Value Object (VO-*)

### 필수 구조
```java
public class Money {
    // 1. 모든 필드 private final
    private final BigDecimal amount;
    private final Currency currency;

    // 2. 생성 시점 검증
    public Money(BigDecimal amount, Currency currency) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new InvalidMoneyException("Amount must be non-negative");
        }
        this.amount = amount;
        this.currency = Objects.requireNonNull(currency);
    }

    // 3. 불변 연산 (새 객체 반환)
    public Money add(Money other) {
        validateSameCurrency(other);
        return new Money(this.amount.add(other.amount), this.currency);
    }

    // 4. 동등성 구현
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Money money)) return false;
        return amount.compareTo(money.amount) == 0
            && currency == money.currency;
    }

    @Override
    public int hashCode() {
        return Objects.hash(amount.stripTrailingZeros(), currency);
    }
}
```

### VO 규칙 상세

| Code | Rule | Severity |
|------|------|----------|
| VO-001 | 모든 필드 final | CRITICAL |
| VO-002 | 생성자에서 검증 | CRITICAL |
| VO-003 | equals/hashCode 구현 | CRITICAL |
| VO-004 | 불변 연산 (새 객체 반환) | CRITICAL |
| VO-005 | Setter 금지 | BLOCKER |
| VO-006 | 불변성 필수 | BLOCKER |
| VO-007 | 의미 있는 네이밍 | MAJOR |

### ID Value Object
```java
public class OrderId {
    private final Long value;

    public OrderId(Long value) {
        if (value == null || value <= 0) {
            throw new InvalidOrderIdException("OrderId must be positive");
        }
        this.value = value;
    }

    public Long value() { return value; }

    @Override
    public boolean equals(Object o) { ... }

    @Override
    public int hashCode() { ... }

    @Override
    public String toString() {
        return "OrderId(" + value + ")";
    }
}
```

---

## Domain Event (EVT-*)

### 필수 구조 (Record 권장)
```java
// Record로 구현 (권장)
public record OrderConfirmedEvent(
    OrderId orderId,
    Instant occurredAt
) implements DomainEvent {

    public OrderConfirmedEvent {
        Objects.requireNonNull(orderId, "orderId must not be null");
        Objects.requireNonNull(occurredAt, "occurredAt must not be null");
    }
}
```

### EVT 규칙 상세

| Code | Rule | Severity |
|------|------|----------|
| EVT-001 | 과거형 네이밍 | MAJOR |
| EVT-002 | 불변 데이터 | CRITICAL |
| EVT-003 | DomainEvent 인터페이스 구현 | MAJOR |
| EVT-004 | 발생 시각 포함 | MAJOR |
| EVT-005 | Aggregate ID 포함 | CRITICAL |

### 이벤트 네이밍
```java
// ✅ GOOD - 과거형
OrderCreatedEvent
OrderConfirmedEvent
PaymentCompletedEvent

// ❌ BAD - 현재형/명령형
CreateOrderEvent
ConfirmOrderEvent
```

---

## Domain Exception (EXC-*)

### 필수 구조
```java
public class OrderNotFoundException extends DomainException {
    private static final String ERROR_CODE = "ORDER_NOT_FOUND";

    public OrderNotFoundException(OrderId orderId) {
        super(ERROR_CODE, "Order not found: " + orderId.value());
    }
}

// Base Exception
public abstract class DomainException extends RuntimeException {
    private final String errorCode;

    protected DomainException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }

    public String errorCode() { return errorCode; }
}
```

### EXC 규칙 상세

| Code | Rule | Severity |
|------|------|----------|
| EXC-001 | DomainException 상속 | BLOCKER |
| EXC-002 | 에러 코드 필수 | CRITICAL |
| EXC-003 | 도메인 언어 사용 | MAJOR |
| EXC-004 | 원인 정보 포함 | MAJOR |

### 예외 네이밍 패턴
```java
// Entity 관련
{Entity}NotFoundException        // 조회 실패
{Entity}AlreadyExistsException  // 중복
Invalid{Entity}Exception        // 무효한 상태

// 비즈니스 규칙
{Rule}ViolationException       // 규칙 위반
Insufficient{Resource}Exception // 자원 부족
```

---

## Domain Service (DSVC-*)

### 사용 시점
- 여러 Aggregate 걸쳐 있는 로직
- Aggregate에 넣기 어색한 도메인 로직
- 외부 시스템 없이 순수 도메인 연산

```java
public class OrderPriceCalculator {

    public Money calculateTotalPrice(Order order, DiscountPolicy policy) {
        Money subtotal = order.subtotal();
        Money discount = policy.calculateDiscount(subtotal);
        return subtotal.subtract(discount);
    }
}
```

### DSVC 규칙

| Code | Rule | Severity |
|------|------|----------|
| DSVC-001 | 상태 없음 (Stateless) | CRITICAL |
| DSVC-002 | 외부 의존성 금지 | CRITICAL |
| DSVC-003 | 순수 도메인 로직만 | MAJOR |

---

## Long FK 전략

타 Aggregate 참조 시 ID만 저장합니다.

```java
// ❌ BAD - Aggregate 직접 참조
public class Order {
    private final Customer customer;  // 다른 Aggregate
}

// ✅ GOOD - ID로 참조
public class Order {
    private final CustomerId customerId;  // ID만 저장
}
```

### 이유
1. **Aggregate 경계 명확화**: 트랜잭션 범위 제한
2. **느슨한 결합**: 변경 영향 최소화
3. **성능**: 불필요한 로딩 방지
4. **모듈 분리 용이**: 마이크로서비스 전환 대비

---

## 참조 문서
- 전체 규칙: `.claude/knowledge/rules/domain-rules.md` (214개)
- 클래스 템플릿: `.claude/knowledge/templates/domain-templates.md` (16개)
- GOOD/BAD 예제: `.claude/knowledge/examples/domain-examples.md` (73개)
